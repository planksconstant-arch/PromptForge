"""
Project Manager Service (Python Port)
Autonomous project decomposition and management
"""

import uuid
import time
import math
import collections
from typing import List, Dict, Optional, Any, Union
from pydantic import BaseModel

# ============================================================================
# TYPE DEFINITIONS
# ============================================================================

class Task(BaseModel):
    id: str
    title: str
    description: str
    status: str = 'pending' # pending, in_progress, completed, blocked
    priority: str = 'medium' # low, medium, high, critical
    estimatedMinutes: int = 60
    dependencies: List[str] = []
    tags: List[str] = []
    deadline: Optional[float] = None
    createdAt: float
    completedAt: Optional[float] = None

class ProjectTimeline(BaseModel):
    startDate: float
    estimatedCompletion: float
    actualCompletion: Optional[float] = None

class Project(BaseModel):
    id: str
    name: str
    description: str
    tasks: List[Task]
    status: str = 'planning' # planning, active, completed, paused
    progress: float = 0.0
    timeline: ProjectTimeline
    autoGenerated: bool = False
    documents: List[str] = []

class DecompositionResult(BaseModel):
    project: Project
    reasoning: str

# ============================================================================
# PROJECT MANAGER
# ============================================================================

class ProjectManager:
    def __init__(self):
        self.projects: Dict[str, Project] = {}
        # TODO: Load state from persistence layer

    async def create_project(self, goal: str, deadline: Optional[float] = None) -> DecompositionResult:
        # Decompose goal into tasks
        tasks = await self._decompose_goal(goal)
        
        # Analyze dependencies
        self._analyze_dependencies(tasks)
        
        # Estimate timeline
        estimated_duration_minutes = sum(t.estimatedMinutes for t in tasks)
        estimated_completion = time.time() + (estimated_duration_minutes * 60)
        
        project_id = str(uuid.uuid4())
        project = Project(
            id=project_id,
            name=self._extract_project_name(goal),
            description=goal,
            tasks=tasks,
            status='planning',
            progress=0,
            timeline=ProjectTimeline(
                startDate=time.time(),
                estimatedCompletion=deadline or estimated_completion
            ),
            autoGenerated=True,
            documents=[]
        )
        
        self.projects[project_id] = project
        
        # Auto-generate initial documentation (mocked)
        # await self.generate_project_doc(project.id)
        
        hours = round(estimated_duration_minutes / 60)
        return DecompositionResult(
            project=project,
            reasoning=f'Broke down "{goal}" into {len(tasks)} manageable tasks with estimated completion in {hours} hours.'
        )

    async def _decompose_goal(self, goal: str) -> List[Task]:
        tasks: List[Task] = []
        templates = self._get_template_for_goal(goal)
        
        for template in templates:
            tasks.append(Task(
                id=str(uuid.uuid4()),
                title=template['title'],
                description=template['description'],
                status='pending',
                priority=template.get('priority', 'medium'),
                estimatedMinutes=template.get('estimatedMinutes', 60),
                dependencies=[],
                tags=self._extract_tags(goal),
                createdAt=time.time()
            ))
            
        return tasks

    def _get_template_for_goal(self, goal: str) -> List[Dict]:
        lower = goal.lower()
        
        # Study/Learning projects
        if any(x in lower for x in ['study', 'learn', 'course']):
            return [
                {'title': 'Gather learning resources', 'description': 'Find tutorials, docs, and materials', 'estimatedMinutes': 30},
                {'title': 'Create study schedule', 'description': 'Plan when to study each topic', 'estimatedMinutes': 20},
                {'title': 'Set up practice environment', 'description': 'Install tools or prepare workspace', 'estimatedMinutes': 45},
                {'title': 'Complete main learning', 'description': 'Go through core material', 'estimatedMinutes': 180},
                {'title': 'Practice exercises', 'description': 'Apply knowledge with practice problems', 'estimatedMinutes': 120},
                {'title': 'Review and test knowledge', 'description': 'Self-assessment and review', 'estimatedMinutes': 60}
            ]

        # Website/App projects
        if any(x in lower for x in ['website', 'app', 'build']):
            return [
                {'title': 'Define requirements', 'description': 'List all features and constraints', 'priority': 'high', 'estimatedMinutes': 45},
                {'title': 'Design architecture', 'description': 'Plan technical structure', 'estimatedMinutes': 60},
                {'title': 'Set up development environment', 'description': 'Install tools and dependencies', 'estimatedMinutes': 30},
                {'title': 'Implement core features', 'description': 'Build main functionality', 'estimatedMinutes': 300},
                {'title': 'Add styling and UX', 'description': 'Design and polish interface', 'estimatedMinutes': 120},
                {'title': 'Test and debug', 'description': 'Fix issues and test thoroughly', 'estimatedMinutes': 90},
                {'title': 'Deploy', 'description': 'Publish to production', 'estimatedMinutes': 45}
            ]

        # Research projects
        if any(x in lower for x in ['research', 'investigate']):
            return [
                {'title': 'Define research question', 'description': 'Clarify what to investigate', 'estimatedMinutes': 20},
                {'title': 'Find sources', 'description': 'Gather papers, articles, and data', 'estimatedMinutes': 60},
                {'title': 'Read and take notes', 'description': 'Process all sources', 'estimatedMinutes': 180},
                {'title': 'Synthesize findings', 'description': 'Combine insights', 'estimatedMinutes': 90},
                {'title': 'Write summary', 'description': 'Document key takeaways', 'estimatedMinutes': 60}
            ]

        # Generic
        return [
            {'title': 'Planning and research', 'description': 'Understand requirements', 'estimatedMinutes': 60},
            {'title': 'Break down into sub-tasks', 'description': 'Create detailed task list', 'estimatedMinutes': 30},
            {'title': 'Implement/Execute', 'description': 'Do the main work', 'estimatedMinutes': 240},
            {'title': 'Review and refine', 'description': 'Polish and improve', 'estimatedMinutes': 60},
            {'title': 'Finalize', 'description': 'Complete and deliver', 'estimatedMinutes': 30}
        ]

    def _extract_project_name(self, goal: str) -> str:
        words = goal.split()[:5]
        return " ".join(words)

    def _extract_tags(self, goal: str) -> List[str]:
        tags = []
        lower = goal.lower()
        if any(x in lower for x in ['study', 'learn']): tags.append('learning')
        if any(x in lower for x in ['build', 'create']): tags.append('development')
        if 'research' in lower: tags.append('research')
        if 'website' in lower: tags.append('web')
        if any(x in lower for x in ['urgent', 'asap']): tags.append('urgent')
        return tags

    def _analyze_dependencies(self, tasks: List[Task]):
        for i in range(1, len(tasks)):
            current = tasks[i]
            previous = tasks[i - 1]
            
            # Simple heuristic
            status_related = current.title.lower().startswith('deploy') or current.title.lower().startswith('finalize')
            keyword_related = 'implement' in current.title.lower() and 'design' in previous.title.lower()
            
            if status_related or keyword_related:
                current.dependencies.append(previous.id)

    def get_all_projects(self) -> List[Project]:
        return list(self.projects.values())

    def get_project(self, project_id: str) -> Optional[Project]:
        return self.projects.get(project_id)

project_manager = ProjectManager()
